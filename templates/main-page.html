<html>
    <head></head>
    <body style="background-color: #deeaee;">
    <div class="messages-container"></div>
    <div style="background-color: teal;">
        <h1 id="greeting"></h1> <button id="show-error-log-btn" style="display: inline; float: right;">SHOW ERROR LOG</button>

        <input id="server-name" placeholder="Server Name" />
        <input id="char-name" placeholder="Character Name" />
        <button id="add-char-btn" style="font-size: 20px;">Add Character</button>
    </div>
    <p id="notification" style="color: red; background-color: yellow;"></p>

    <div style="background-color: #92a8d1;">
        <h1>Characters You Are Currently Tracking:</h1>
        <button id="refresh" style="visibility: hidden;">Refresh</button>
        <span id="character-status"></span>
        <ul id="character-list"></ul>
    </div>
    <script>
        const electron = require('electron');
        const ipcRenderer = electron.ipcRenderer;
        const characterListElement = document.getElementById('character-list');
        const os = require('os');

        document.getElementById('show-error-log-btn').addEventListener('click', () => {
            ipcRenderer.send('show:error-log');
        });


        /**
         * Try to fetch machine name so we can use it in a greeting
         * If it fails, we simply print a generic greeting
         */
        let greetingSuffix;
        try {
            greetingSuffix = `, ${os.hostname()}`;
        } catch (err) {
            greetingSuffix = ` there`;
        }
        document.getElementById('greeting').innerHTML = `Hello${greetingSuffix}!`;

        const serverNameInput = document.getElementById('server-name');
        const characterNameInput = document.getElementById('char-name');

        const addCharacterButton = document.getElementById('add-char-btn');

        /*
         * Pressing Enter in either of the two inputs either calls addCharacter, or shifts focus to the other input,
         * depending on which input is missing a value
         */
        serverNameInput.addEventListener('keypress', event => {
            shiftFocusOrAddCharacter(event, serverNameInput, characterNameInput);
        });

        characterNameInput.addEventListener('keypress', event => {
            shiftFocusOrAddCharacter(event, characterNameInput, serverNameInput);
        });

        addCharacterButton.addEventListener('click', addCharacter);

        let notificationTimeout;
        const notificationElement = document.getElementById('notification');
        const showNotification = message => {
            clearTimeout(notificationTimeout);
            notificationElement.innerHTML = message;
            notificationTimeout = setTimeout(() => {
                notificationElement.innerHTML = '';
            }, 5000);
        };

        const refreshButton = document.getElementById('refresh');
        refreshButton.addEventListener('click', () => {
            ipcRenderer.send('refresh:characters');
        });

        // === IPC EVENT LISTENERS ===

        ipcRenderer.on('get:last-server', (event, lastServer) => {
            // attempt to fetch last used server name from db and auto-populate the input if it is present
            serverNameInput.value = lastServer ? lastServer : '';

            // focus the field that is more likely to get its value populated (char name if server is auto-populated; server name otherwise)
            if (!serverNameInput.value) {
                serverNameInput.focus();
            } else {
                characterNameInput.focus();
            }
        });
        /**
         * Displays the current status of the character list
         * For example, it could say that character data is being loaded, or that there are no characters to show
         */
        const characterStatusElement = document.getElementById('character-status');

        // TODO rework to only trigger when mass-fetch gets issued
        ipcRenderer.on('character-fetch:in-progress', event => {
            characterStatusElement.innerHTML = 'Loading latest data...';
            refreshButton.style.visibility = 'hidden';
        });

        ipcRenderer.on('character:fetch-complete', (event, character) => {
            // find appropriate 'li' based on 'character-identifier' property
            const characterIdentifier = (character.name + character.server).replace(' ', '');

            const liElements = document.getElementsByTagName('li');
            let li;
            for (let i = 0; i < liElements.length; i++) {
                if (liElements[i].getAttribute('character-identifier') === characterIdentifier) {
                    li = liElements[i];
                    break;
                }
            }

            // now that we have the right 'li' element, we can purge its innerHTML and re-populate it with the latest info
            li.innerHTML = '';
            handleCharacterLi(li, character);
        });

        // TODO get rid of
        ipcRenderer.on('render:characters', (event, characters) => {
            characterStatusElement.innerHTML = '';
            if (!Array.isArray(characters) || characters.length === 0) {
                characterListElement.innerHTML = '';
                return characterStatusElement.innerHTML =
                    'No Characters To Show. Click "Add Character" To Start Tracking One';
            }
            refreshButton.style.visibility = 'visible';

            characterListElement.innerHTML = '';
            characters.forEach(character => {
                const li = document.createElement('li');
                const itemText = document.createTextNode(`${character.name} (${character.level}) / ${character.server} - `);
                li.appendChild(itemText);

                const removeButton = document.createElement('button');
                const buttonText = document.createTextNode('Remove');
                removeButton.appendChild(buttonText);

                removeButton.addEventListener('click', () => {
                    // TODO handle through a checkbox
                    li.style.color = 'red';
                    li.removeChild(removeButton);

                    const removingSpan = document.createElement('span');
                    const spanText = document.createTextNode('Removing...');
                    removingSpan.appendChild(spanText);
                    removingSpan.style.color = 'red';

                    li.appendChild(removingSpan);

                    ipcRenderer.send('character:remove', character._id);
                });

                li.appendChild(removeButton);

                characterListElement.appendChild(li);
            });
        });

        // === HELPER FUNCTIONS ===
        function addCharacter () {
            const character = {
                name: characterNameInput.value,
                server: serverNameInput.value
            };

            //validate character
            let errorMessage = '';
            if (typeof character.name !== 'string' || character.name.length < 2) {
                errorMessage += 'Character Name must be at least two letters long. ';
            }

            if (typeof character.server !== 'string' || character.server.length < 2) {
                errorMessage += 'Server Name must be at least two letters long.';
            }

            if (errorMessage.length > 0) {
                showNotification(errorMessage);
                return;
            }
// ============ WIP
            /**
             * Immediately place the character into the list and mark their level as PENDING
             * Make sure the relevant HTML element (li) has a unique reference to the character, so we can later update it
             */
            const li = document.createElement('li');
            handleCharacterLi(li, character);
// ============= WIP

            ipcRenderer.send('add:character', character);

            // save server name as lastServer so we can use it between application restarts
            ipcRenderer.send('update:last-server', character.server);

            // clear out character name field and shift focus to it
            characterNameInput.value = '';
            characterNameInput.focus();

        }

        /**
         * Accepts an 'li' element along with all the data needed to create all the sub-elements and append the 'li'
         * into the relevant 'ul'
         */
        function handleCharacterLi(li, character) {
            let bracketInfo;
            if (character.level) {
                bracketInfo = character.level;
            } else if (character.nonExistent) {
                bracketInfo = 'NOT-FOUND';
            } else {
                bracketInfo = 'PENDING';
            }

            const itemText = document.createTextNode(`${character.name} (${bracketInfo}) / ${character.server} - `);
            li.appendChild(itemText);

            const removeButton = document.createElement('button');
            const buttonText = document.createTextNode('Remove');
            removeButton.appendChild(buttonText);
            // TODO add event listener to btn
            li.appendChild(removeButton);

            // used to uniquely identify the 'li' element
            const characterIdentifier = (character.name + character.server).replace(' ', '');
            li.setAttribute('character-identifier', characterIdentifier);

            // TODO add identifier attribute to li
            // characterListElement is accessed globally
            characterListElement.appendChild(li);
        }

        /**
         * Checks whether the key pressed was Enter
         * If so, determines whether to shift focus from 'self' to 'other' or call addCharacter
         */
        function shiftFocusOrAddCharacter(event, self, other) {
            if (event.key !== 'Enter') {
                return;
            }

            if (self.value && !other.value) {
                return other.focus();
            }

            addCharacter();
        }

    </script>
    </body>
</html>
